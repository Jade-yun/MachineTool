#include "Orderjoint.h"
#include <cstring>
#include "stdlib.h"

uint8_t ParValue[10] = {0};
uint8_t PgmListDis[PGMLISTMAXLEN] = {0};  //每条程序编号
uint8_t PgmContDis[PGMCONTMAXLEN] = {0};  //每条程序具体内容
/*************************************************************************
**  函数名：  tag_valueToStr()
**	输入参数：无
**	输出参数：
**	函数功能：数值转字符串
**  作者：    wukui
**  开发日期：2023/12/26
**************************************************************************/
void tag_valueToStr(uint32_t temp_value)
{//数值转字符串
    if(temp_value<10)
    {
        ParValue[0]=0x20;
        ParValue[1]=0x20;
        ParValue[2]=0x20;
        ParValue[3]=temp_value%10+0x30;
    }
    else if(temp_value<100)
    {
        ParValue[0]=0x20;
        ParValue[1]=0x20;
        ParValue[2]=temp_value/10%10+0x30;
        ParValue[3]=temp_value%10+0x30;
    }
    else if(temp_value < 1000)
    {
        ParValue[0]=temp_value/100%10+0x30;
        ParValue[1]=temp_value/10%10+0x30;
        ParValue[2]=temp_value%10+0x30;
        ParValue[3]=0x20;
    }
    else if(temp_value < 10000)
    {
        ParValue[0]=temp_value/1000%10+0x30;
        ParValue[1]=temp_value/100%10+0x30;
        ParValue[2]=temp_value/10%10+0x30;
        ParValue[3]=temp_value%10+0x30;
    }
    else if(temp_value < 100000)
    {
        ParValue[0]=temp_value/10000%10+0x30;
        ParValue[1]=temp_value/1000%10+0x30;
        ParValue[2]=temp_value/100%10+0x30;
        ParValue[3]=temp_value/10%10+0x30;
        ParValue[4]=temp_value%10+0x30;
    }
}
/*************************************************************************
**  函数名：  ValueToString()
**	输入参数：无
**	输出参数：
**	函数功能：参数值转变为文本
**  作者：    wukui
**  开发日期：2023/12/26
**************************************************************************/
void ValueToString(uint32_t Temp_Value)
{
    uint8_t j = 0;
    uint8_t k = 0;
    for(j=0; j<10; j++)
    {
        ParValue[j] = 0;
    }
    if(Temp_Value>>28 == 0x0f)
    {//坐标设置
        Temp_Value = (Temp_Value & 0x0fffffff);
        j=9;
        if(Temp_Value==0)
        {
            ParValue[0]=0x20;
            ParValue[1]=0x20;
            ParValue[2]=0x20;
            ParValue[3]=0x20;
            ParValue[4]=0x20;
            ParValue[5]=0x20;
            ParValue[6]=0x30;
            ParValue[7]=0x2E;
            ParValue[8]=0x30;
            ParValue[9]=0x30;
        }
        else
        {
            if(Temp_Value>=100)
            {
                while((Temp_Value!=0) && (j!=0))
                {
                    if(j==7)
                    {
                        ParValue[j]=0x2E;
                    }
                    else
                    {
                        ParValue[j]=Temp_Value%10+0x30;
                        Temp_Value=Temp_Value/10;
                    }
                    j--;
                }
            }
            else if(Temp_Value<100)
            {
                while(j!=0)
                {
                    if(j==6)
                    {
                        ParValue[j]=0x2E;
                    }
                    else
                    {
                        ParValue[j]=Temp_Value%10+0x30;
                        Temp_Value=Temp_Value/10;
                    }
                    j--;
                    if(j==5)break;
                }
            }

            for(k=0; k<=j; k++)
            {
                ParValue[k]=0x20;
            }
        }
    }
    else if(Temp_Value>>12 == 0x0e)
    {//速度设置
        Temp_Value = Temp_Value & 0xffff0fff;
        if(Temp_Value==0)
        {
            ParValue[0]=0x20;
            ParValue[1]=0x20;
            ParValue[2]=0x20;
            ParValue[3]=0x20;
            ParValue[4]=0x20;
            ParValue[5]=0x20;
            ParValue[6]=0x20;
            ParValue[7]=0x30;
            ParValue[8]=0x2E;
            ParValue[9]=0x30;
        }
        else
        {
            ParValue[9]=0x20;
            ParValue[8]=0x25;		   //%
            j=7;
            while((Temp_Value!=0) && (j!=0))
            {
                ParValue[j]=Temp_Value%10+0x30;
                Temp_Value=Temp_Value/10;
                j--;
            }
            for(k=0; k<=j; k++)
            {
                ParValue[k]=0x20;
            }
        }
    }
    else if(Temp_Value>>28 == 0x0d)
    {//时间设置
        Temp_Value = Temp_Value & 0x0fffffff;
        ParValue[9]=0x20;
        ParValue[8]=0x73;			//s   	//100->1.00s
        if(Temp_Value<100)
        {
            ParValue[0]=0x20;
            ParValue[1]=0x20;
            ParValue[2]=0x20;
            ParValue[3]=0x20;
            ParValue[4]=0x30;
            ParValue[5]=0x2E;
            ParValue[6]=Temp_Value/10+0x30;
            ParValue[7]=Temp_Value%10+0x30;
        }
        else
        {
            j=7;
            while((Temp_Value != 0) && (j != 0))
            {
                if(j==5)
                {
                    ParValue[j]=0x2E;
                }
                else
                {
                    ParValue[j]=Temp_Value%10+0x30;			//100->1.00
                    Temp_Value=Temp_Value/10;
                }
                j--;
            }
            for(k=0; k<=j; k++)
            {
                ParValue[k]=0x20;
            }
        }
    }
    else if(Temp_Value>>28 == 0x0c)
    {//行号/IO选择
        Temp_Value = Temp_Value & 0x0fffffff;
        j=7;
        if(Temp_Value==0)
        {
            ParValue[7] = 0x30;
            j--;
        }
        else
        {
            while((Temp_Value!=0) && (j!=0))
            {
                ParValue[j]=Temp_Value%10+0x30;
                Temp_Value=Temp_Value/10;
                j--;
            }
        }
        for(k=0; k<=j; k++)
        {
            ParValue[k]=0x20;
        }
    }
    else if(Temp_Value>>28 == 0x0b)
    {//R数量/I状态选择
        Temp_Value = Temp_Value & 0x0fffffff;
        ParValue[9]=0x20;
        j=7;
        if(Temp_Value==0)
        {
            ParValue[7] = 0x30;
            j--;
        }
        else
        {
            while((Temp_Value!=0) && (j!=0))
            {
                ParValue[j]=Temp_Value%10+0x30;
                Temp_Value=Temp_Value/10;
                j--;
            }
        }
        for(k=0; k<=j; k++)
        {
            ParValue[k]=0x20;
        }
    }
    else if(Temp_Value>>28 == 0x0a)
    {//2位小数点的负数
        //Temp_Value = abs(Temp_Value);
        Temp_Value = Temp_Value & 0x0fffffff;
        ParValue[9]=0x6D;
        ParValue[8]=0x6D;			//mm
        if(Temp_Value<100)
        {
            ParValue[0]=0x20;
            ParValue[1]=0x20;
            ParValue[2]=0x20;
            ParValue[3]=0x2D;
            ParValue[4]=0x30;
            ParValue[5]=0x2E;
            ParValue[6]=Temp_Value/10+0x30;
            ParValue[7]=Temp_Value%10+0x30;
        }
        else
        {
            j=7;
            while((Temp_Value!=0) && (j!=0))
            {
                if(j==5)
                {
                    ParValue[j]=0x2E;
                }
                else
                {
                    ParValue[j]=Temp_Value%10+0x30;
                    Temp_Value=Temp_Value/10;
                }
                j--;
            }
            ParValue[j]=0x2D;// - 号
            if(j>0)//是否要先判断j>0
            {
                j--;
                for(k=0; k<=j; k++)
                {
                    ParValue[k]=0x20;
                }
            }
        }
    }
    else if(Temp_Value>>28 == 0x09)
    {//正数
        Temp_Value = Temp_Value & 0x0fffffff;
        ParValue[9]=0x6D;
        ParValue[8]=0x6D;			//mm
        if(Temp_Value<100)
        {
            ParValue[0]=0x20;
            ParValue[1]=0x20;
            ParValue[2]=0x20;
            ParValue[3]=0x20;
            ParValue[4]=0x20;
            ParValue[5]=Temp_Value/10+0x30;
            ParValue[6]=0x2E;
            ParValue[7]=Temp_Value%10+0x30;
        }
        else
        {
            j=7;
            while((Temp_Value!=0) && (j!=0))
            {
                if(j==6)
                {
                    ParValue[j]=0x2E;
                }
                else
                {
                    ParValue[j]=Temp_Value%10+0x30;
                    Temp_Value=Temp_Value/10;
                }
                j--;
            }
            for(k=0; k<=j; k++)
            {
                ParValue[k]=0x20;
            }
        }
    }
    else if(Temp_Value>>28 == 0x08)
    {//正整数
        Temp_Value = Temp_Value & 0x0fffffff;
        ParValue[9]=0x6D;
        ParValue[8]=0x6D;			//mm

        if(Temp_Value<100)
        {
            ParValue[0]=0x20;
            ParValue[1]=0x20;
            ParValue[2]=0x20;
            ParValue[3]=0x20;
            ParValue[4]=0x20;
            ParValue[5]=0x20;
            ParValue[6]=Temp_Value/10+0x30;
            ParValue[7]=Temp_Value%10+0x30;
        }
        else
        {
            j=7;
            while((Temp_Value!=0) && (j!=0))
            {
                ParValue[j]=Temp_Value%10+0x30;
                Temp_Value=Temp_Value/10;
                j--;
            }
            for(k=0; k<=j; k++)
            {
                ParValue[k]=0x20;
            }
        }
    }
    else if(Temp_Value>>28 == 0x07)
    {//1位小数点的负数
        Temp_Value = Temp_Value | 0xf0000000;//负数的最高位为1, 0x7=0111，所以要先把最高位或成1,不然下面取绝对值时认为是正数
        //Temp_Value = abs(Temp_Value);
        Temp_Value = Temp_Value & 0x0fffffff;
        ParValue[9]=0x20;
        ParValue[8]=0x20;
        if(Temp_Value<100)
        {
            ParValue[0]=0x20;
            ParValue[1]=0x20;
            ParValue[2]=0x20;
            ParValue[3]=0x20;
            ParValue[4]=0x2D;
            ParValue[5]=0x30;
            ParValue[6]=0x2E;
            ParValue[7]=Temp_Value%10+0x30;
        }
        else
        {
            j=7;
            while((Temp_Value!=0) && (j!=0))
            {
                if(j==6)
                {
                    ParValue[j]=0x2E;
                }
                else
                {
                    ParValue[j]=Temp_Value%10+0x30;
                    Temp_Value=Temp_Value/10;
                }
                j--;
            }
            ParValue[j]=0x2D;// - 号
            if(j>0)
            {
                j--;
                for(k=0; k<=j; k++)
                {
                    ParValue[k]=0x20;
                }
            }
        }
    }
    else if(Temp_Value>>28 == 0x00)
    {//uint8_t、uint16_t的正整数
        tag_valueToStr(Temp_Value);
    }

}

/*************************************************************************
**  函数名：  CodeAndContInit()
**	输入参数：无
**	输出参数：
**	函数功能：指令编号和内容初始化函数
**  作者：    wukui
**  开发日期：2023/12/26
**************************************************************************/
void CodeAndContInit(void)
{
    uint8_t i = 0;

    for(i=0;i<PGMLISTMAXLEN;i++)
    {
        PgmListDis[i] = 0x20;
    }
    for(i=0;i<PGMCONTMAXLEN;i++)
    {
        PgmContDis[i] = 0x20;
    }
}

/*************************************************************************
**  函数名：  LeaveBlankSpace()
**	输入参数：size-字符串长度，value-字符串内容
**	输出参数：
**	函数功能：去除字符串空间的空白
**  作者：    wukui
**  开发日期：2023/12/26
**************************************************************************/
void LeaveBlankSpace(uint8_t size, uint8_t *value)
{
    uint8_t i = 0;
    uint8_t j = 0;
    uint8_t k = 0;
    uint8_t allSpaceFlag = 0;
    for(i=0;i<size;i++)//去除多余的空格
    {
        if(value[i] == 0x20 || value[i] == '\t')
        {
            for(j=i;j<size-1;j++)
            {
                value[j] = value[j+1];
            }
            value[size-1] = 0x20;
            i--;
        }
        for(k=i+1;k<size;k++)
        {
            if(value[k] != 0x20)
                break;
            if(k==size-1)
                allSpaceFlag = 1;
        }
        if(allSpaceFlag)
            break;
    }
}

/*************************************************************************
**  函数名：  JointStrDeal()
**	输入参数：指令信息结构体变量
**	输出参数：
**	函数功能：拼接处理函数
**  作者：    wukui
**  开发日期：2024/08/12
**************************************************************************/
void JointStrDeal(P_ProOrderStruct OIS)
{
    switch(OIS.cmd)
    {
        case C_AXIS_MOVE:	//轴动作
            AxisActJoint(OIS, PgmListDis, PgmContDis);
            break;
//        case STACKORDER:		//堆叠
//            StackJoint(line, OIS, PgmListDis, PgmContDis);
//            break;
//        case JXSOUTORDER:		//机械手输出
//            JXSOutJoint(line, OIS, PgmListDis, PgmContDis);
//            break;
//        case ZSJOUTORDER:		//注塑机输出
//            ZSJOutJoint(line, OIS, PgmListDis, PgmContDis);
//            break;
//        case DETECTORDER:		//检测
//            DetectJoint(line, OIS, PgmListDis, PgmContDis);
//            break;
//        case WAITORDER:			//等待
//            WaitJoint(line, OIS, PgmListDis, PgmContDis);
//            break;
//        case LABELORDER:		//标签
//            LabelJoint(line, OIS, PgmListDis, PgmContDis);
//            break;
//        case CONDITORDER:		//条件
//            ConditJoint(line, OIS, PgmListDis, PgmContDis);
//            break;
//        case PROENDORDER:		//程序结束
//            ProEndJoint(line, OIS, PgmListDis, PgmContDis);
//            break;
        default:
//            CodeAndContInit();
            break;
    }
}
/*************************************************************************
**  函数名：  AxisActJoint()
**	输入参数：指令信息结构体变量
**	输出参数：
**	函数功能：轴动作指令拼接显示
**  作者：    wukui
**  开发日期：2024/08/12
**************************************************************************/
QString AxisActJoint(P_ProOrderStruct OIS,uint8_t* contStr)
{
    /************************************
     * 拼接内容包括:
     * 1.参考点名称
     * 2.轴名称
     * 3.位置mm
     * 4.速度%
     * 5.提前mm
     * 6.延时s
     ************************************/
    QStringList contStrList;
    P_AxisMoveStruct* pAxisAct = (P_AxisMoveStruct*)OIS.pData;

    if(pAxisAct->referPointNum != 0)
    {//如果指定了参考点
        contStrList.append();

    }


//    //参考点名称名称
//    memset(contStr,0x20,PGMNAMEMAXLEN);
//    memcpy(contStr, OIS.note, PGMNAMEMAXLEN);

//    if(pAxisAct->axis < 6)
//    {//[主引拔X :]速度:延时s
//        if((pAxisAct->axis == 3 || pAxisAct->axis == 4) && pAxisAct->subType == 1)
//        {
//            if(pAxisAct->pneuState == 0)
//            {
//                for(i=0; i<14; i++)
//                {//	[副臂后退] / [副臂上升]
//                    contStr[18+i] = PgmContStr[90+(pAxisAct->axis-3)*2][i];
//                }
//            }
//            else
//            {
//                for(i=0; i<14; i++)
//                {//	[副臂前进] / [副臂下降]
//                    contStr[18+i] = PgmContStr[91+(pAxisAct->axis-3)*2][i];
//                }
//            }
//            for(i=32; i<19; i++)
//            {
//                contStr[i] = 0x20;//填0x20
//            }
//        }
//        else
//        {
//            for(i=0; i<13; i++)
//            {//	[主引拔X :
//                contStr[18+i] = PgmContStr[pAxisAct->axis+1][i];
//            }

//            ValueToString(pAxisAct->posMM | 0xf0000000);
//            for(i=0; i<7; i++)
//            {//	位置值
//                contStr[31+i] = ParValue[3+i];
//            }

//            for(i=0; i<8; i++)
//            {//	]速度:
//                contStr[38+i] = PgmContStr[pAxisAct->axis+1][13+i];
//            }

//            ValueToString(pAxisAct->speed);
//            for(i=0; i<4; i++)
//            {//	速度值
//                contStr[46+i] = ParValue[i];
//            }
//        }
//    }
//    else if(pAxisAct->axis >= 6 && pAxisAct->axis < 8)
//    {
//        if(pAxisAct->pneuState == 0)
//        {
//            for(i=0; i<20; i++)
//            {//	[主臂倒角水平] / [副臂倒角水平]
//                contStr[18+i] = PgmContStr[94+(pAxisAct->axis-6)*2][i];
//            }
//        }
//        else
//        {
//            for(i=0; i<20; i++)
//            {//	[主臂倒角垂直] / [副臂倒角垂直]
//                contStr[18+i] = PgmContStr[95+(pAxisAct->axis-6)*2][i];
//            }
//        }
//        for(i=38; i<13; i++)
//        {
//            contStr[i] = 0x20;//填0x20
//        }
//    }

//    if(pAxisAct->delay == 0)
//    {
//        for(i=51; i<PGMCONTMAXLEN; i++)
//        {
//            contStr[i] = 0x20;
//        }
//    }
//    else
//    {
//        for(i=0; i<6; i++)
//        {//	延时
//            contStr[51+i] = PgmContStr[1][21+i];
//        }

//        ValueToString(pAxisAct->delay | 0xd0000000);
//        for(i=0;i<8;i++)
//        {//	延时值 s
//            contStr[57+i] = ParValue[2+i];
//        }

//        for(i=65; i<PGMCONTMAXLEN; i++)
//        {
//            contStr[i] = 0x20;
//        }
//    }

//    for(i=0; i<PGMCONTMAXLEN; i++)
//    {//填充0x20
//        if(contStr[i] == 0x00)
//        {
//            contStr[i] = 0x20;
//        }
//    }
//    LeaveBlankSpace(PGMCONTMAXLEN, contStr);//去除0x20
}
/*************************************************************************
**  函数名：  StackJoint()
**	输入参数：指令信息结构体变量
**	输出参数：
**	函数功能：堆叠指令拼接显示
**  作者：    wukui
**  开发日期：2023/12/26
**************************************************************************/
void StackJoint(uint16_t line, ProOrderStruct OIS, uint8_t* listStr, uint8_t* contStr)
{
    uint8_t i=0;
    StackOrderStruct* pStack = (StackOrderStruct*)OIS.pData;

    if(line == 999)
    {//起点*
        for(i=0; i<8; i++)
        {
            listStr[i] = PgmStartStr[0][i];
        }
    }
    else
    {
        for(i=0; i<8; i++)
        {
            listStr[i] = PgmListStr[line+1][i];
        }
    }
    for(i=8; i<PGMLISTMAXLEN; i++)
    {
        listStr[i] = 0x20;
    }

    //自定义名称
    memcpy(contStr, OIS.note, PGMNAMEMAXLEN);

    //[堆叠开始:第组]
    for(i=0; i<17; i++)
    {//	[堆叠开始:第
         contStr[18+i] = PgmContStr[7][i];
    }
    ValueToString(pStack->groupNum+1);
    for(i=0; i<4; i++)
    {//	组号值
        contStr[35+i] = ParValue[i];
    }
    for(i=0; i<4; i++)
    {//	组]
        contStr[39+i] = PgmContStr[7][17+i];
    }
    for(i=43; i<PGMCONTMAXLEN; i++)
    {
        contStr[i] = 0x20;
    }
    for(i=0; i<PGMCONTMAXLEN; i++)
    {//填充0x20
        if(contStr[i] == 0x00)
        {
            contStr[i] = 0x20;
        }
    }
    LeaveBlankSpace(PGMCONTMAXLEN, contStr);//去除0x20
}
/*************************************************************************
**  函数名：  JXSOutJoint()
**	输入参数：指令信息结构体变量
**	输出参数：
**	函数功能：机械手输出指令拼接显示
**  作者：    wukui
**  开发日期：2023/12/26
**************************************************************************/
void JXSOutJoint(uint16_t line, ProOrderStruct OIS, uint8_t* listStr, uint8_t* contStr)
{
    uint8_t i=0;
    JXSOutOrderStruct* pJXSOut = (JXSOutOrderStruct*)OIS.pData;

    if(line == 999)
    {//起点*
        for(i=0; i<8; i++)
        {
            listStr[i] = PgmStartStr[0][i];
        }
    }
    else
    {
        for(i=0; i<8; i++)
        {
            listStr[i] = PgmListStr[line+1][i];
        }
    }
    for(i=8; i<PGMLISTMAXLEN; i++)
    {
        listStr[i] = 0x20;
    }

    //自定义名称
    memcpy(contStr, OIS.note, PGMNAMEMAXLEN);

    if(pJXSOut->port == 11 || pJXSOut->port == 12 || pJXSOut->port == 23 || pJXSOut->port == 24)
    {//[吸具  ]延时s
        for(i=0; i<7; i++)
        {//	[吸具
            contStr[18+i] = PgmContStr[58][i];
        }

        if(pJXSOut->port == 11)
            ValueToString(1);
        else if(pJXSOut->port == 12)
            ValueToString(2);
        else if(pJXSOut->port == 23)
            ValueToString(3);
        else if(pJXSOut->port == 24)
            ValueToString(4);
        for(i=0; i<4; i++)
        {//	吸具号
            contStr[25+i] = ParValue[i];
        }

        if(pJXSOut->type == 0)
        {//	断
            for(i=0; i<3; i++)
            {
                contStr[29+i] = PgmContStr[57][i];
            }
        }
        else
        {//	通
            for(i=0; i<3; i++)
            {
                contStr[29+i] = PgmContStr[57][3+i];
            }
        }

        if(pJXSOut->delay == 0)
        {//	]
            contStr[32] = PgmContStr[58][9];
            for(i=33; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
        else
        {//	]延时s
            for(i=0; i<7; i++)
            {//	]延时
                contStr[32+i] = PgmContStr[58][9+i];
            }
            ValueToString(pJXSOut->delay | 0xd0000000);
            for(i=0;i<8;i++)
            {//	延时值 s
                contStr[39+i] = ParValue[2+i];
            }
            for(i=47; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
    }
    else if(pJXSOut->port == 13 || pJXSOut->port == 14 || pJXSOut->port == 15 || pJXSOut->port == 16)
    {//[抱具  ]延时s
        for(i=0; i<7; i++)
        {//	[抱具
            contStr[18+i] = PgmContStr[59][i];
        }

        if(pJXSOut->port == 13)
            ValueToString(1);
        else if(pJXSOut->port == 14)
            ValueToString(2);
        else if(pJXSOut->port == 15)
            ValueToString(3);
        else if(pJXSOut->port == 16)
            ValueToString(4);
        for(i=0; i<4; i++)
        {//	抱具号
            contStr[25+i] = ParValue[i];
        }

        if(pJXSOut->type == 0)
        {//	断
            for(i=0; i<3; i++)
            {
                contStr[29+i] = PgmContStr[57][i];
            }
        }
        else
        {//	通
            for(i=0; i<3; i++)
            {
                contStr[29+i] = PgmContStr[57][3+i];
            }
        }

        if(pJXSOut->delay == 0)
        {//	]
            contStr[32] = PgmContStr[59][9];
            for(i=33; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
        else
        {//	]延时s
            for(i=0; i<7; i++)
            {//	]延时
                contStr[32+i] = PgmContStr[59][9+i];
            }
            ValueToString(pJXSOut->delay | 0xd0000000);
            for(i=0;i<8;i++)
            {//	延时值 s
                contStr[39+i] = ParValue[2+i];
            }
            for(i=47; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
    }
    else if(pJXSOut->port == 26)
    {//[副臂夹]延时s
        for(i=0; i<10; i++)
        {//	[副臂夹
            contStr[18+i] = PgmContStr[60][i];
        }

        if(pJXSOut->type == 0)
        {//	断
            for(i=0; i<3; i++)
            {
                contStr[28+i] = PgmContStr[57][i];
            }
        }
        else
        {//	通
            for(i=0; i<3; i++)
            {
                contStr[28+i] = PgmContStr[57][3+i];
            }
        }

        if(pJXSOut->delay == 0)
        {//	]
            contStr[31] = PgmContStr[60][10];
            for(i=32; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
        else
        {//	]延时s
            for(i=0; i<7; i++)
            {//	]延时
                contStr[31+i] = PgmContStr[60][10+i];
            }
            ValueToString(pJXSOut->delay | 0xd0000000);
            for(i=0;i<8;i++)
            {//	延时值 s
                contStr[38+i] = ParValue[2+i];
            }
            for(i=46; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
    }
    else if(pJXSOut->port == 8 || pJXSOut->port == 7 || pJXSOut->port == 21 || pJXSOut->port == 22)
    {//[打油  ]间隔模数:动作时间:s
        if(pJXSOut->port == 8)
        {//	[打油
            for(i=0; i<7; i++)
            {
                contStr[18+i] = PgmContStr[61][i];
            }
            contStr[25] = 0x20;
            contStr[26] = 0x20;
            contStr[27] = 0x20;
        }
        else if(pJXSOut->port == 7)
        {//	[输送带
            for(i=0; i<10; i++)
            {
                contStr[18+i] = PgmContStr[62][i];
            }
        }
        else if(pJXSOut->port == 21)
        {
            for(i=0; i<10; i++)
            {//	[送料机
                contStr[18+i] = PgmContStr[63][i];
            }
        }
        else if(pJXSOut->port == 22)
        {
            for(i=0; i<7; i++)
            {//	[剪刀
                contStr[18+i] = PgmContStr[64][i];
            }
            contStr[25] = 0x20;
            contStr[26] = 0x20;
            contStr[27] = 0x20;
        }

        if(pJXSOut->type == 0)
        {//	断
            for(i=0; i<3; i++)
            {
                contStr[28+i] = PgmContStr[57][i];
            }
            contStr[31] = 0x20;
            contStr[32] = 0x20;
            contStr[33] = 0x20;
        }
        else
        {//	通/脉冲
            if(pJXSOut->port == 8 || pJXSOut->port == 7)
            {
                for(i=0; i<6; i++)
                {
                    contStr[28+i] = PgmContStr[57][6+i];
                }
            }
            else
            {
                for(i=0; i<3; i++)
                {
                    contStr[28+i] = PgmContStr[57][3+i];
                }
                contStr[31] = 0x20;
                contStr[32] = 0x20;
                contStr[33] = 0x20;
            }
        }

        //	]
        contStr[34] = PgmContStr[61][9];

        //间隔模数:
        if(pJXSOut->interval == 0)
        {//空
            for(i=0; i<13; i++)
            {//	间隔模数:
                contStr[35+i] = 0x20;//空
            }
            for(i=0;i<4;i++)
            {//	模数值
                contStr[48+i] = 0x20;//空
            }
        }
        else
        {//间隔模数:
            for(i=0; i<13; i++)
            {//	间隔模数:
                contStr[35+i] = PgmContStr[61][10+i];
            }
            ValueToString(pJXSOut->interval);
            for(i=0;i<4;i++)
            {//	模数值
                contStr[48+i] = ParValue[2+i];
            }
        }

        //延时s
        if(pJXSOut->delay == 0)
        {//空
            for(i=0; i<9; i++)
            {//	延时s
                contStr[52+i] = 0x20;//空
            }
            for(i=0;i<4;i++)
            {//	时间值
                contStr[61+i] = 0x20;//空
            }
        }
        else
        {//延时s
            if(pJXSOut->port == 8)
            {//动作时间:
                for(i=0; i<13; i++)
                {//	动作时间:
                    contStr[52+i] = PgmContStr[61][23+i];
                }
                ValueToString(pJXSOut->delay | 0xd0000000);
                for(i=0;i<8;i++)
                {//	时间值
                    contStr[65+i] = ParValue[2+i];
                }
            }
            else
            {//延时
                for(i=0; i<7; i++)
                {//	:延时
                    contStr[52+i] = PgmContStr[62][23+i];
                }
                ValueToString(pJXSOut->delay | 0xd0000000);
                for(i=0;i<8;i++)
                {//	时间值
                    contStr[59+i] = ParValue[2+i];
                }
                for(i=0;i<8;i++)
                {
                    contStr[67+i] = 0x20;
                }
            }
            for(i=73; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
    }
    else if(pJXSOut->port == 17 || pJXSOut->port == 18 || pJXSOut->port == 19 || pJXSOut->port == 20 || pJXSOut->port == 27 || pJXSOut->port == 28)
    {//[Y17   ]间隔模数:延时s
        //[Y
        for(i=0; i<2; i++)
        {
            contStr[18+i] = PgmContStr[65][i];
        }

        //17/18/19/20/27/28
        ValueToString(pJXSOut->port);
        for(i=0;i<4;i++)
        {//	输出口
            contStr[20+i] = ParValue[2+i];
        }

        if(pJXSOut->type == 0)
        {//	断
            for(i=0; i<3; i++)
            {
                contStr[24+i] = PgmContStr[57][i];
            }
        }
        else
        {//	通
            for(i=0; i<3; i++)
            {
                contStr[24+i] = PgmContStr[57][3+i];
            }
        }

        //	]
        contStr[27] = PgmContStr[65][7];

        //间隔模数:
        if(pJXSOut->interval == 0)
        {//空
            for(i=0; i<13; i++)
            {//	间隔模数:
                contStr[28+i] = 0x20;//空
            }
            for(i=0;i<4;i++)
            {//	模数值
                contStr[41+i] = 0x20;//空
            }
        }
        else
        {//间隔模数:
            for(i=0; i<13; i++)
            {//	间隔模数:
                contStr[28+i] = PgmContStr[65][8+i];
            }
            ValueToString(pJXSOut->interval);
            for(i=0;i<4;i++)
            {//	模数值
                contStr[41+i] = ParValue[2+i];
            }
        }

        //延时s
        if(pJXSOut->delay == 0)
        {//空
            for(i=0; i<9; i++)
            {//	延时s
                contStr[45+i] = 0x20;//空
            }
            for(i=0;i<4;i++)
            {//	时间值
                contStr[54+i] = 0x20;//空
            }
        }
        else
        {//延时s
            for(i=0; i<6; i++)
            {//	延时
                contStr[45+i] = PgmContStr[62][24+i];
            }
            ValueToString(pJXSOut->delay | 0xd0000000);
            for(i=0;i<8;i++)
            {//	时间值
                contStr[51+i] = ParValue[2+i];
            }

            for(i=59; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
    }

    for(i=0; i<PGMCONTMAXLEN; i++)
    {//填充0x20
        if(contStr[i] == 0x00)
        {
            contStr[i] = 0x20;
        }
    }
    LeaveBlankSpace(PGMCONTMAXLEN, contStr);//去除0x20
}
/*************************************************************************
**  函数名：  ZSJOutJoint()
**	输入参数：指令信息结构体变量
**	输出参数：
**	函数功能：注塑机输出指令拼接显示
**  作者：    wukui
**  开发日期：2023/12/26
**************************************************************************/

void ZSJOutJoint(uint16_t line, ProOrderStruct OIS, uint8_t* listStr, uint8_t* contStr)
{
    uint8_t i=0;
    ZSJOutOrderStruct* pZSJOut = (ZSJOutOrderStruct*)OIS.pData;

    if(line == 999)
    {//起点*
        for(i=0; i<8; i++)
        {
            listStr[i] = PgmStartStr[0][i];
        }
    }
    else
    {
        for(i=0; i<8; i++)
        {
            listStr[i] = PgmListStr[line+1][i];
        }
    }
    for(i=8; i<PGMLISTMAXLEN; i++)
    {
        listStr[i] = 0x20;
    }

    //自定义名称
    memcpy(contStr, OIS.note, PGMNAMEMAXLEN);

    //[
    contStr[18] = PgmContStr[67][0];

    //禁止/允许
    if(pZSJOut->type == 0)
    {
        for(i=0; i<6; i++)
        {//	禁止
            contStr[19+i] = PgmContStr[66][i];
        }
    }
    else
    {
        for(i=0; i<6; i++)
        {//	允许
            contStr[19+i] = PgmContStr[66][6+i];
        }
    }

    //关模 ]
    if(pZSJOut->port == 1)
    {
        for(i=0; i<8; i++)
        {//	关模 ]
            contStr[25+i] = PgmContStr[67][1+i];
        }
    }
    else if(pZSJOut->port == 3)
    {
        for(i=0; i<8; i++)
        {//	顶进 ]
            contStr[25+i] = PgmContStr[68][1+i];
        }
    }
    else if(pZSJOut->port == 51)
    {
        for(i=0; i<8; i++)
        {//	顶退 ]
            contStr[25+i] = PgmContStr[69][1+i];
        }
    }
    else if(pZSJOut->port == 52)
    {
        for(i=0; i<8; i++)
        {//	抽1进]
            contStr[25+i] = PgmContStr[70][1+i];
        }
    }
    else if(pZSJOut->port == 53)
    {
        for(i=0; i<8; i++)
        {//	抽1退]
            contStr[25+i] = PgmContStr[71][1+i];
        }
    }
    else if(pZSJOut->port == 54)
    {
        for(i=0; i<8; i++)
        {//	抽2进]
            contStr[25+i] = PgmContStr[72][1+i];
        }
    }
    else if(pZSJOut->port == 55)
    {
        for(i=0; i<8; i++)
        {//	抽2退]
            contStr[25+i] = PgmContStr[73][1+i];
        }
    }

    if(pZSJOut->delay == 0)
    {
        for(i=0; i<6; i++)
        {//	延时
            contStr[33+i] = 0x20;
        }

        for(i=0; i<8; i++)
        {//	延时值s 空
            contStr[39+i] = 0x20;
        }
    }
    else
    {
        for(i=0; i<6; i++)
        {//	延时
            contStr[33+i] = PgmContStr[67][9+i];
        }

        ValueToString(pZSJOut->delay | 0xd0000000);
        for(i=0; i<8; i++)
        {//	延时值s
            contStr[39+i] = ParValue[2+i];
        }
    }

    for(i=47; i<PGMCONTMAXLEN; i++)
    {
        contStr[i] = 0x20;
    }
    for(i=0; i<PGMCONTMAXLEN; i++)
    {//填充0x20
        if(contStr[i] == 0x00)
        {
            contStr[i] = 0x20;
        }
    }
    LeaveBlankSpace(PGMCONTMAXLEN, contStr);//去除0x20
}
/*************************************************************************
**  函数名：  DetectJoint()
**	输入参数：指令信息结构体变量
**	输出参数：
**	函数功能：检测指令拼接显示
**  作者：    wukui
**  开发日期：2023/12/26
**************************************************************************/

void DetectJoint(uint16_t line, ProOrderStruct OIS, uint8_t* listStr, uint8_t* contStr)
{
    uint16_t i=0;
    DetectOrderStruct* pDetect = (DetectOrderStruct*)OIS.pData;

    if(line == 999)
    {//起点*
        for(i=0; i<8; i++)
        {
            listStr[i] = PgmStartStr[0][i];
        }
    }
    else
    {
        for(i=0; i<8; i++)
        {
            listStr[i] = PgmListStr[line+1][i];
        }
    }
    for(i=8; i<PGMLISTMAXLEN; i++)
    {
        listStr[i] = 0x20;
    }

    //自定义名称
    memcpy(contStr, OIS.note, PGMNAMEMAXLEN);

    if(pDetect->port == 14)
    {
        for(i=0; i<8; i++)
        {//	[吸具1
            contStr[18+i] = PgmContStr[75][i];
        }
        contStr[26] = 0x20;
        contStr[27] = 0x20;
    }
    else if(pDetect->port == 15)
    {
        for(i=0; i<8; i++)
        {//	[吸具2
            contStr[18+i] = PgmContStr[76][i];
        }
        contStr[26] = 0x20;
        contStr[27] = 0x20;
    }
    else if(pDetect->port == 9)
    {
        for(i=0; i<8; i++)
        {//	[吸具3
            contStr[18+i] = PgmContStr[77][i];
        }
        contStr[26] = 0x20;
        contStr[27] = 0x20;
    }
    else if(pDetect->port == 10)
    {
        for(i=0; i<8; i++)
        {//	[吸具4
            contStr[18+i] = PgmContStr[78][i];
        }
        contStr[26] = 0x20;
        contStr[27] = 0x20;
    }
    else if(pDetect->port == 16)
    {
        for(i=0; i<8; i++)
        {//	[抱具1
            contStr[18+i] = PgmContStr[79][i];
        }
        contStr[26] = 0x20;
        contStr[27] = 0x20;
    }
    else if(pDetect->port == 17)
    {
        for(i=0; i<8; i++)
        {//	[抱具2
            contStr[18+i] = PgmContStr[80][i];
        }
        contStr[26] = 0x20;
        contStr[27] = 0x20;
    }
    else if(pDetect->port == 18)
    {
        for(i=0; i<8; i++)
        {//	[抱具3
            contStr[18+i] = PgmContStr[81][i];
        }
        contStr[26] = 0x20;
        contStr[27] = 0x20;
    }
    else if(pDetect->port == 19)
    {
        for(i=0; i<8; i++)
        {//	[抱具4
            contStr[18+i] = PgmContStr[82][i];
        }
        contStr[26] = 0x20;
        contStr[27] = 0x20;
    }
    else if(pDetect->port == 26)
    {
        for(i=0; i<10; i++)
        {//	[副臂夹
            contStr[18+i] = PgmContStr[83][i];
        }
    }

    if(pDetect->type == 0)
    {//	不检测
        for(i=0; i<9; i++)
        {
            contStr[28+i] = PgmContStr[74][i];
        }
        contStr[37] = 0x20;
        contStr[38] = 0x20;
        contStr[39] = 0x20;
        contStr[40] = 0x20;
        contStr[41] = 0x20;
        contStr[42] = 0x20;
        contStr[43] = 0x20;
    }
    else if(pDetect->type == 1)
    {//	检测输入ON
        for(i=0; i<14; i++)
        {
            contStr[28+i] = PgmContStr[74][9+i];
        }
        contStr[42] = 0x20;
        contStr[43] = 0x20;
    }
    else if(pDetect->type == 2)
    {//	检测输入OFF
        for(i=0; i<15; i++)
        {
            contStr[28+i] = PgmContStr[74][23+i];
        }
    }

    if(pDetect->delay == 0)
    {
        //	]
        contStr[43] = PgmContStr[75][9];

        for(i=44; i<PGMCONTMAXLEN; i++)
        {
            contStr[i] = 0x20;
        }
    }
    else
    {//	]延时s
        for(i=0; i<7; i++)
        {//	]延时
            contStr[42+i] = PgmContStr[75][9+i];
        }

        ValueToString(pDetect->delay | 0xd0000000);
        for(i=0;i<8;i++)
        {//	延时值 s
            contStr[49+i] = ParValue[2+i];
        }
    }

    for(i=57; i<PGMCONTMAXLEN; i++)
    {
        contStr[i] = 0x20;
    }
    for(i=0; i<PGMCONTMAXLEN; i++)
    {//填充0x20
        if(contStr[i] == 0x00)
        {
            contStr[i] = 0x20;
        }
    }
    LeaveBlankSpace(PGMCONTMAXLEN, contStr);//去除0x20
}

/*************************************************************************
**  函数名：  WaitJoint()
**	输入参数：指令信息结构体变量
**	输出参数：
**	函数功能：等待指令拼接显示
**  作者：    wukui
**  开发日期：2023/12/26
**************************************************************************/

void WaitJoint(uint16_t line, ProOrderStruct OIS, uint8_t* listStr, uint8_t* contStr)
{
    uint8_t i=0;
    WaitOrderStruct* pWait = (WaitOrderStruct*)OIS.pData;

    if(line == 999)
    {//起点*
        for(i=0; i<8; i++)
        {
            listStr[i] = PgmStartStr[0][i];
        }
    }
    else
    {
        for(i=0; i<8; i++)
        {
            listStr[i] = PgmListStr[line+1][i];
        }
    }
    for(i=8; i<PGMLISTMAXLEN; i++)
    {
        listStr[i] = 0x20;
    }

    //自定义名称
    memcpy(contStr, OIS.note, PGMNAMEMAXLEN);

    if(pWait->wait == 0)
    {//[等待开模]延时s
        if(pWait->timeout == 0)
        {//[等待开模]
            for(i=0; i<14; i++)
            {//	[等待开模]
                contStr[18+i] = PgmContStr[36][i];
            }
            for(i=32; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
        else
        {//[等待开模]延时s
            for(i=0; i<20; i++)
            {//	[等待开模]延时
                contStr[18+i] = PgmContStr[36][i];
            }
            ValueToString(pWait->timeout | 0xd0000000);
            for(i=0;i<8;i++)
            {//	延时值 s
                contStr[38+i] = ParValue[2+i];
            }
            for(i=46; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
    }
    else if(pWait->wait == 16)
    {//[等待抱1确认]限时:s
        if(pWait->timeout == 0)
        {//[等待抱1确认]
            for(i=0; i<18; i++)
            {//	[等待抱1确认]
                contStr[18+i] = PgmContStr[37][i];
            }
            for(i=36; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
        else
        {//[等待抱1确认]限时:s
            for(i=0; i<25; i++)
            {//	[等待抱1确认]限时:
                contStr[18+i] = PgmContStr[37][i];
            }
            ValueToString(pWait->timeout | 0xd0000000);
            for(i=0;i<8;i++)
            {//	延时值 s
                contStr[43+i] = ParValue[2+i];
            }
            for(i=51; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
    }
    else if(pWait->wait == 17)
    {//[等待抱2确认]限时:s
        if(pWait->timeout == 0)
        {//[等待抱2确认]
            for(i=0; i<18; i++)
            {//	[等待抱2确认]
                contStr[18+i] = PgmContStr[38][i];
            }
            for(i=36; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
        else
        {//[等待抱2确认]限时:s
            for(i=0; i<15; i++)
            {//	[等待抱2确认]限时:
                contStr[25+i] = PgmContStr[38][i];
            }
            ValueToString(pWait->timeout | 0xd0000000);
            for(i=0;i<8;i++)
            {//	延时值 s
                contStr[40+i] = ParValue[2+i];
            }
            for(i=48; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
    }
    else if(pWait->wait == 18)
    {//[等待抱3确认]限时:s
        if(pWait->timeout == 0)
        {//[等待抱3确认]
            for(i=0; i<18; i++)
            {//	[等待抱3确认]
                contStr[18+i] = PgmContStr[39][i];
            }
            for(i=36; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
        else
        {//[等待抱3确认]限时:s
            for(i=0; i<25; i++)
            {//	[等待抱3确认]限时:
                contStr[18+i] = PgmContStr[39][i];
            }
            ValueToString(pWait->timeout | 0xd0000000);
            for(i=0;i<8;i++)
            {//	延时值 s
                contStr[43+i] = ParValue[2+i];
            }
            for(i=51; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
    }
    else if(pWait->wait == 19)
    {//[等待抱4确认]限时:s
        if(pWait->timeout == 0)
        {//[等待抱4确认]
            for(i=0; i<18; i++)
            {//	[等待抱4确认]
                contStr[18+i] = PgmContStr[40][i];
            }
            for(i=36; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
        else
        {//[等待抱4确认]限时:s
            for(i=0; i<25; i++)
            {//	[等待抱4确认]限时:
                contStr[18+i] = PgmContStr[40][i];
            }
            ValueToString(pWait->timeout | 0xd0000000);
            for(i=0;i<8;i++)
            {//	延时值 s
                contStr[43+i] = ParValue[2+i];
            }
            for(i=51; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
    }
    else if(pWait->wait == 26)
    {//[等待副臂夹]限时:s
        if(pWait->timeout == 0)
        {//[等待副臂夹]
            for(i=0; i<17; i++)
            {//	[等待副臂夹]
                contStr[18+i] = PgmContStr[41][i];
            }
            for(i=35; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
        else
        {//[等待副臂夹]限时:s
            for(i=0; i<24; i++)
            {//	[等待副臂夹]限时:
                contStr[18+i] = PgmContStr[41][i];
            }
            ValueToString(pWait->timeout | 0xd0000000);
            for(i=0;i<8;i++)
            {//	延时值 s
                contStr[42+i] = ParValue[2+i];
            }
            for(i=50; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
    }
    else if(pWait->wait == 11)
    {//[等待X11]限时:s
        if(pWait->timeout == 0)
        {//[等待X11]
            for(i=0; i<11; i++)
            {//	[等待X11]
                contStr[18+i] = PgmContStr[42][i];
            }
            for(i=29; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
        else
        {//[等待X11]限时:s
            for(i=0; i<18; i++)
            {//	[等待X11]限时:
                contStr[18+i] = PgmContStr[42][i];
            }
            ValueToString(pWait->timeout | 0xd0000000);
            for(i=0;i<8;i++)
            {//	延时值 s
                contStr[36+i] = ParValue[2+i];
            }
            for(i=44; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
    }
    else if(pWait->wait == 27)
    {//[等待X27]限时:s
        if(pWait->timeout == 0)
        {//[等待X27]
            for(i=0; i<11; i++)
            {//	[等待X27]
                contStr[18+i] = PgmContStr[43][i];
            }
            for(i=29; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
        else
        {//[等待X27]限时:s
            for(i=0; i<18; i++)
            {//	[等待X27]限时:
                contStr[18+i] = PgmContStr[43][i];
            }
            ValueToString(pWait->timeout | 0xd0000000);
            for(i=0;i<8;i++)
            {//	延时值 s
                contStr[36+i] = ParValue[2+i];
            }
            for(i=44; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
    }
    else if(pWait->wait == 31)
    {//[等待X31]限时:s
        if(pWait->timeout == 0)
        {//[等待X31]
            for(i=0; i<11; i++)
            {//	[等待X31]
                contStr[18+i] = PgmContStr[44][i];
            }
            for(i=29; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
        else
        {//[等待X31]限时:s
            for(i=0; i<18; i++)
            {//	[等待X31]限时:
                contStr[18+i] = PgmContStr[44][i];
            }
            ValueToString(pWait->timeout | 0xd0000000);
            for(i=0;i<8;i++)
            {//	延时值 s
                contStr[36+i] = ParValue[2+i];
            }
            for(i=44; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
    }
    else if(pWait->wait == 32)
    {//[等待X32]限时:s
        if(pWait->timeout == 0)
        {//[等待X32]
            for(i=0; i<11; i++)
            {//	[等待X32]
                contStr[18+i] = PgmContStr[45][i];
            }
            for(i=29; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
        else
        {//[等待X32]限时:s
            for(i=0; i<18; i++)
            {//	[等待X32]限时:
                contStr[18+i] = PgmContStr[45][i];
            }
            ValueToString(pWait->timeout | 0xd0000000);
            for(i=0;i<8;i++)
            {//	延时值 s
                contStr[36+i] = ParValue[2+i];
            }
            for(i=44; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
    }
    else if(pWait->wait == 2)
    {//[等待安全门关]限时:s
        if(pWait->timeout == 0)
        {//[等待安全门关]
            for(i=0; i<20; i++)
            {//	[等待安全门关]
                contStr[18+i] = PgmContStr[46][i];
            }
            for(i=38; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
        else
        {//[等待安全门关]限时:s
            for(i=0; i<27; i++)
            {//	[等待安全门关]限时:
                contStr[18+i] = PgmContStr[46][i];
            }
            ValueToString(pWait->timeout | 0xd0000000);
            for(i=0;i<8;i++)
            {//	延时值 s
                contStr[45+i] = ParValue[2+i];
            }
            for(i=53; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
    }
    else if(pWait->wait == 14)
    {//[等待吸1确认]限时:s
        if(pWait->timeout == 0)
        {//[等待吸1确认]
            for(i=0; i<18; i++)
            {//	[等待吸1确认]
                contStr[18+i] = PgmContStr[47][i];
            }
            for(i=36; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
        else
        {//[等待吸1确认]限时:s
            for(i=0; i<25; i++)
            {//	[等待吸1确认]限时:
                contStr[18+i] = PgmContStr[47][i];
            }
            ValueToString(pWait->timeout | 0xd0000000);
            for(i=0;i<8;i++)
            {//	延时值 s
                contStr[43+i] = ParValue[2+i];
            }
            for(i=51; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
    }
    else if(pWait->wait == 15)
    {//[等待吸2确认]限时:s
        if(pWait->timeout == 0)
        {//[等待吸2确认]
            for(i=0; i<18; i++)
            {//	[等待吸2确认]
                contStr[18+i] = PgmContStr[48][i];
            }
            for(i=36; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
        else
        {//[等待吸2确认]限时:s
            for(i=0; i<25; i++)
            {//	[等待吸2确认]限时:
                contStr[18+i] = PgmContStr[48][i];
            }
            ValueToString(pWait->timeout | 0xd0000000);
            for(i=0;i<8;i++)
            {//	延时值 s
                contStr[43+i] = ParValue[2+i];
            }
            for(i=51; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
    }
    else if(pWait->wait == 9)
    {//[等待吸3确认]限时:s
        if(pWait->timeout == 0)
        {//[等待吸3确认]
            for(i=0; i<18; i++)
            {//	[等待吸3确认]
                contStr[18+i] = PgmContStr[49][i];
            }
            for(i=36; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
        else
        {//[等待吸3确认]限时:s
            for(i=0; i<25; i++)
            {//	[等待吸3确认]限时:
                contStr[18+i] = PgmContStr[49][i];
            }
            ValueToString(pWait->timeout | 0xd0000000);
            for(i=0;i<8;i++)
            {//	延时值 s
                contStr[43+i] = ParValue[2+i];
            }
            for(i=51; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
    }
    else if(pWait->wait == 10)
    {//[等待吸4确认]限时:s
        if(pWait->timeout == 0)
        {//[等待吸4确认]
            for(i=0; i<18; i++)
            {//	[等待吸4确认]
                contStr[18+i] = PgmContStr[50][i];
            }
            for(i=36; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
        else
        {//[等待吸4确认]限时:s
            for(i=0; i<25; i++)
            {//	[等待吸4确认]限时:
                contStr[18+i] = PgmContStr[50][i];
            }
            ValueToString(pWait->timeout | 0xd0000000);
            for(i=0;i<8;i++)
            {//	延时值 s
                contStr[43+i] = ParValue[2+i];
            }
            for(i=51; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
    }
    else if(pWait->wait == 51)
    {//[等待顶针进到位]限时:s
        if(pWait->timeout == 0)
        {//[等待顶针进到位]
            for(i=0; i<23; i++)
            {//	[等待顶针进到位]
                contStr[18+i] = PgmContStr[51][i];
            }
            for(i=40; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
        else
        {//[等待顶针进到位]限时:s
            for(i=0; i<30; i++)
            {//	[等待顶针进到位]限时:
                contStr[18+i] = PgmContStr[51][i];
            }
            ValueToString(pWait->timeout | 0xd0000000);
            for(i=0;i<8;i++)
            {//	延时值 s
                contStr[48+i] = ParValue[2+i];
            }
            for(i=56; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
    }
    else if(pWait->wait == 52)
    {//[等待顶针退到位]限时:s
        if(pWait->timeout == 0)
        {//[等待顶针退到位]
            for(i=0; i<23; i++)
            {//	[等待顶针退到位]
                contStr[18+i] = PgmContStr[52][i];
            }
            for(i=41; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
        else
        {//[等待顶针退到位]限时:s
            for(i=0; i<30; i++)
            {//	[等待顶针退到位]限时:
                contStr[18+i] = PgmContStr[52][i];
            }
            ValueToString(pWait->timeout | 0xd0000000);
            for(i=0;i<8;i++)
            {//	延时值 s
                contStr[48+i] = ParValue[2+i];
            }
            for(i=56; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
    }
    else if(pWait->wait == 53)
    {//[等待抽1进到位]限时:s
        if(pWait->timeout == 0)
        {//[等待抽1进到位]
            for(i=0; i<21; i++)
            {//	[等待抽1进到位]
                contStr[18+i] = PgmContStr[53][i];
            }
            for(i=39; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
        else
        {//[等待抽1进到位]限时:s
            for(i=0; i<28; i++)
            {//	[等待抽1进到位]限时:
                contStr[18+i] = PgmContStr[53][i];
            }
            ValueToString(pWait->timeout | 0xd0000000);
            for(i=0;i<8;i++)
            {//	延时值 s
                contStr[46+i] = ParValue[2+i];
            }
            for(i=54; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
    }
    else if(pWait->wait == 54)
    {//[等待抽1退到位]限时:s
        if(pWait->timeout == 0)
        {//[等待抽1退到位]
            for(i=0; i<21; i++)
            {//	[等待抽1退到位]
                contStr[18+i] = PgmContStr[54][i];
            }
            for(i=39; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
        else
        {//[等待抽1退到位]限时:s
            for(i=0; i<28; i++)
            {//	[等待抽1退到位]限时:
                contStr[18+i] = PgmContStr[54][i];
            }
            ValueToString(pWait->timeout | 0xd0000000);
            for(i=0;i<8;i++)
            {//	延时值 s
                contStr[46+i] = ParValue[2+i];
            }
            for(i=54; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
    }
    else if(pWait->wait == 55)
    {//[等待抽2进到位]限时:s
        if(pWait->timeout == 0)
        {//[等待抽2进到位]
            for(i=0; i<21; i++)
            {//	[等待抽2进到位]
                contStr[18+i] = PgmContStr[55][i];
            }
            for(i=39; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
        else
        {//[等待抽2进到位]限时:s
            for(i=0; i<28; i++)
            {//	[等待抽2进到位]限时:
                contStr[18+i] = PgmContStr[55][i];
            }
            ValueToString(pWait->timeout | 0xd0000000);
            for(i=0;i<8;i++)
            {//	延时值 s
                contStr[46+i] = ParValue[2+i];
            }
            for(i=54; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
    }
    else if(pWait->wait == 56)
    {//[等待抽2退到位]限时:s
        if(pWait->timeout == 0)
        {//[等待抽2退到位]
            for(i=0; i<21; i++)
            {//	[等待抽2退到位]
                contStr[18+i] = PgmContStr[56][i];
            }
            for(i=39; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
        else
        {//[等待抽2退到位]限时:s
            for(i=0; i<28; i++)
            {//	[等待抽2退到位]限时:
                contStr[18+i] = PgmContStr[56][i];
            }
            ValueToString(pWait->timeout | 0xd0000000);
            for(i=0;i<8;i++)
            {//	延时值 s
                contStr[46+i] = ParValue[2+i];
            }
            for(i=54; i<PGMCONTMAXLEN; i++)
            {
                contStr[i] = 0x20;
            }
        }
    }

    for(i=0; i<PGMCONTMAXLEN; i++)
    {//填充0x20
        if(contStr[i] == 0x00)
        {
            contStr[i] = 0x20;
        }
    }
    LeaveBlankSpace(PGMCONTMAXLEN, contStr);//去除0x20
}

/*************************************************************************
**  函数名：  LabelJoint()
**	输入参数：指令信息结构体变量
**	输出参数：
**	函数功能：标签指令拼接显示
**  作者：    wukui
**  开发日期：2023/12/26
**************************************************************************/

void LabelJoint(uint16_t line, ProOrderStruct OIS, uint8_t* listStr, uint8_t* contStr)
{
    uint8_t i=0;
    LabelOrderStruct* pLabel = (LabelOrderStruct*)OIS.pData;

    if(line == 999)
    {//起点
        for(i=0; i<8; i++)
        {
            listStr[i] = PgmStartStr[0][i];
        }
    }
    else
    {
        for(i=0; i<8; i++)
        {
            listStr[i] = PgmListStr[line+1][i];
        }
    }
    for(i=8; i<PGMLISTMAXLEN; i++)
    {
        listStr[i] = 0x20;
    }

    //自定义名称
    memcpy(contStr, OIS.note, PGMNAMEMAXLEN);

    //[标签0000]
    for(i=0; i<7; i++)
    {//	[标签
        contStr[18+i] = PgmContStr[35][i];
    }
    ValueToString(pLabel->labelNum);
    for(i=0; i<4; i++)
    {//	标签值
        contStr[25+i] = ParValue[i];
    }
    //	]
    contStr[29] = PgmContStr[35][11];

    for(i=30; i<PGMCONTMAXLEN; i++)
    {
        contStr[i] = 0x20;
    }
    for(i=0; i<PGMCONTMAXLEN; i++)
    {//填充0x20
        if(contStr[i] == 0x00)
        {
            contStr[i] = 0x20;
        }
    }
    LeaveBlankSpace(PGMCONTMAXLEN, contStr);//去除0x20
}

/*************************************************************************
**  函数名：  ConditJoint()
**	输入参数：指令信息结构体变量
**	输出参数：
**	函数功能：条件指令拼接显示
**  作者：    wukui
**  开发日期：2023/12/26
**************************************************************************/

void ConditJoint(uint16_t line, ProOrderStruct OIS, uint8_t* listStr, uint8_t* contStr)
{
    uint8_t i=0;
    ConditOrderStruct* pCondit = (ConditOrderStruct*)OIS.pData;

    if(line == 999)
    {//起点
        for(i=0; i<8; i++)
        {
            listStr[i] = PgmStartStr[0][i];
        }
    }
    else
    {
        for(i=0; i<8; i++)
        {
            listStr[i] = PgmListStr[line+1][i];
        }
    }
    for(i=8; i<PGMLISTMAXLEN; i++)
    {
        listStr[i] = 0x20;
    }

    //自定义名称
    memcpy(contStr, OIS.note, PGMNAMEMAXLEN);

    //[
    contStr[18] = PgmContStr[88][0];

    if(pCondit->callnum == 0 || pCondit->callnum == 1 || pCondit->callnum == 2 || pCondit->callnum == 3)
    {//吸 确认
        for(i=0; i<3; i++)
        {//	吸
            contStr[19+i] = PgmContStr[84][0+i];
        }

        ValueToString(pCondit->callnum+1);
        for(i=0; i<6; i++)
        {//	吸号
            contStr[22+i] = ParValue[i];
        }

        for(i=0; i<6; i++)
        {//	确认
            contStr[28+i] = PgmContStr[84][2+i];
        }
    }
    else if(pCondit->callnum == 4 || pCondit->callnum == 5 || pCondit->callnum == 6 || pCondit->callnum == 7)
    {//抱 确认
        for(i=0; i<3; i++)
        {//	抱
            contStr[19+i] = PgmContStr[84][9+i];
        }

        ValueToString(pCondit->callnum-4+1);
        for(i=0; i<6; i++)
        {//	抱号
            contStr[22+i] = ParValue[i];
        }

        for(i=0; i<6; i++)
        {//	确认
            contStr[28+i] = PgmContStr[84][12+i];
        }

        for(i=0; i<2; i++)
        {//	补0x20
            contStr[34+i] = 0x20;
        }
    }
    else if(pCondit->callnum == 8)
    {//副臂夹
        for(i=0; i<9; i++)
        {//	副臂夹
            contStr[19+i] = PgmContStr[84][12+i];
        }

        for(i=0; i<4; i++)
        {//	补0x20
            contStr[28+i] = 0x20;
        }
    }
    else if(pCondit->callnum == 9 || pCondit->callnum == 10 || pCondit->callnum == 11 || pCondit->callnum == 12)
    {//X11/X27/X31/X32
        //	X
        contStr[19] = PgmContStr[84][27];

        if(pCondit->callnum == 9)
            ValueToString(11);
        else if(pCondit->callnum == 10)
            ValueToString(27);
        else if(pCondit->callnum == 11)
            ValueToString(31);
        else if(pCondit->callnum == 12)
            ValueToString(32);
        for(i=0; i<4; i++)
        {//	X端口号
            contStr[20+i] = ParValue[i];
        }

        for(i=0; i<11; i++)
        {//	补0x20
            contStr[24+i] = 0x20;
        }
    }
    else if(pCondit->callnum == 13)
    {//开模完
        for(i=0; i<9; i++)
        {//	开模完
            contStr[19+i] = PgmContStr[85][0+i];
        }

        for(i=0; i<7; i++)
        {//	补0x20
            contStr[28+i] = 0x20;
        }
    }
    else if(pCondit->callnum == 14)
    {//安全门关
        for(i=0; i<12; i++)
        {//	安全门关
            contStr[19+i] = PgmContStr[85][9+i];
        }

        for(i=0; i<4; i++)
        {//	补0x20
            contStr[31+i] = 0x20;
        }
    }
    else if(pCondit->callnum == 15)
    {//无条件
        for(i=0; i<9; i++)
        {//	无条件
            contStr[19+i] = PgmContStr[85][21+i];
        }

        for(i=0; i<7; i++)
        {//	补0x20
            contStr[28+i] = 0x20;
        }
    }
    else if(pCondit->callnum == 16)
    {//不良品试产
        for(i=0; i<15; i++)
        {//	不良品试产
            contStr[19+i] = PgmContStr[86][0+i];
        }
    }
    else if(pCondit->callnum == 17)
    {//抽样
        for(i=0; i<6; i++)
        {//	抽样
            contStr[19+i] = PgmContStr[86][15+i];
        }

        for(i=0; i<10; i++)
        {//	补0x20
            contStr[25+i] = 0x20;
        }
    }

    //断/通
    if(pCondit->type == 0)
    {//断
        for(i=0; i<3; i++)
        {//	断
            contStr[34+i] = PgmContStr[87][0+i];
        }
    }
    else
    {//通
        for(i=0; i<3; i++)
        {//	通
            contStr[34+i] = PgmContStr[87][3+i];
        }
    }
    if(pCondit->callnum == 15)
    {//无条件时不显示通断
        for(i=0; i<3; i++)
        {//	补0x20
            contStr[34+i] = 0x20;
        }
    }

    for(i=0; i<3; i++)
    {//	时
        contStr[37+i] = PgmContStr[88][1+i];
    }

    if(pCondit->subpgm >= 1 && pCondit->subpgm <= 6)
    {
        for(i=0; i<12; i++)
        {//	调子程序
            contStr[40+i] = PgmContStr[88][4+i];
        }
        ValueToString(pCondit->subpgm);
        for(i=0; i<4; i++)
        {//	子程序号
            contStr[52+i] = ParValue[i];
        }
    }
    else if(pCondit->subpgm == 7)
    {
        for(i=0; i<9; i++)
        {//	调试产
            contStr[40+i] = PgmContStr[88][16+i];
        }
        for(i=0; i<8; i++)
        {//	补0x20
            contStr[49+i] = 0x20;
        }
    }
    else if(pCondit->subpgm == 8)
    {
        for(i=0; i<9; i++)
        {//	调抽样
            contStr[40+i] = PgmContStr[88][25+i];
        }
        for(i=0; i<8; i++)
        {//	补0x20
            contStr[49+i] = 0x20;
        }
    }
    else
    {
        for(i=0; i<17; i++)
        {//	空
            contStr[40+i] = 0x20;
        }
    }

    //	]
    contStr[56] = PgmContStr[88][34];

    //跳到标签
    for(i=0; i<12; i++)
    {//	跳到标签
        contStr[57+i] = PgmContStr[89][i];
    }
    ValueToString(pCondit->label);
    for(i=0; i<4; i++)
    {//	标签号
        contStr[69+i] = ParValue[i];
    }

    //限时:
    if(pCondit->delay == 0)
    {
        for(i=0; i<7; i++)
        {//	//限时: 空
            contStr[73+i] = 0x20;
        }
        for(i=0;i<8;i++)
        {//	限时值 s
            contStr[80+i] = 0x20;
        }
    }
    else
    {
        for(i=0; i<7; i++)
        {//	限时:
            contStr[73+i] = PgmContStr[89][12+i];
        }
        ValueToString(pCondit->delay | 0xd0000000);
        for(i=0; i<8; i++)
        {//	限时值 空
            contStr[80+i] = ParValue[2+i];
        }
    }

    //间隔模数
    if(pCondit->interval == 0)
    {
        for(i=0; i<12; i++)
        {//	间隔模数 空
            contStr[88+i] = 0x20;
        }
        for(i=0; i<4; i++)
        {//	模数值		空
            contStr[100+i] = 0x20;
        }
    }
    else
    {
        for(i=0; i<12; i++)
        {//	间隔模数
            contStr[88+i] = PgmContStr[89][19+i];
        }
        ValueToString(pCondit->interval);
        for(i=0; i<4; i++)
        {//	模数值
            contStr[100+i] = ParValue[2+i];
        }
    }

    for(i=0; i<PGMCONTMAXLEN; i++)
    {//填充0x20
        if(contStr[i] == 0x00)
        {
            contStr[i] = 0x20;
        }
    }
    LeaveBlankSpace(PGMCONTMAXLEN, contStr);//去除0x20
}

/*************************************************************************
**  函数名：  ProEndJoint()
**	输入参数：指令信息结构体变量
**	输出参数：
**	函数功能：程序结束指令拼接显示
**  作者：    wukui
**  开发日期：2023/12/26
**************************************************************************/

void ProEndJoint(uint16_t line, ProOrderStruct OIS, uint8_t* listStr, uint8_t* contStr)
{
    uint8_t i=0;

    if(line == 999)
    {//起点
        for(i=0; i<8; i++)
        {
            listStr[i] = PgmStartStr[0][i];
        }
    }
    else
    {
        for(i=0; i<8; i++)
        {
            listStr[i] = PgmListStr[line+1][i];
        }
    }
    for(i=8; i<PGMLISTMAXLEN; i++)
    {
        listStr[i] = 0x20;
    }

    //[程序结束]
    for(i=0; i<14; i++)
    {//	[程序结束]
        contStr[i] = PgmContStr[34][i];
    }

    for(i=14; i<PGMCONTMAXLEN; i++)
    {
        contStr[i] = 0x20;
    }
    for(i=0; i<PGMCONTMAXLEN; i++)
    {//填充0x20
        if(contStr[i] == 0x00)
        {
            contStr[i] = 0x20;
        }
    }
    LeaveBlankSpace(PGMCONTMAXLEN, contStr);//去除0x20
}
